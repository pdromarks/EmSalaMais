import 'package:em_sala_mais/backend/dto/bloco_dto.dart';
import 'package:em_sala_mais/backend/services/bloco.service.dart';
import 'package:flutter/material.dart';
import '../../components/screens/custom_crud_screen.dart'; // Assuming this is correctly defined
import '../../components/screens/custom_form_dialog.dart'; // Assuming this is correctly defined
import 'package:em_sala_mais/backend/model/bloco.dart'; // Your Bloco model
import 'package:em_sala_mais/backend/model/enums.dart'; // Your Campus enum


class BlocoCrudScreen extends StatefulWidget {
  const BlocoCrudScreen({super.key});

  @override
  State<BlocoCrudScreen> createState() => _BlocoCrudScreenState();
}

class _BlocoCrudScreenState extends State<BlocoCrudScreen> {
  late BlocoService _blocoService;
  List<Bloco> _actualBlocos = [];
  bool _isLoading = true;

  // Função para formatar o nome do campus para exibição
  String _getFormattedCampusName(String campusName) {
    switch (campusName.toLowerCase()) {
      case 'maringa':
        return 'Maringá';
      case 'teste':
        return 'Teste';
      // Adicione outros casos conforme necessário, baseados no enum Campus
      default:
        if (campusName.isEmpty) return '';
        // Capitaliza a primeira letra se não houver formatação específica
        return campusName[0].toUpperCase() + campusName.substring(1);
    }
  }

  // Definição das colunas da tabela
  // These columns operate on the Map<String, dynamic> generated by _blocoToMap
  final List<ColumnData> _columns = [
    ColumnData(
      label: 'Nome',
      getValue: (item) => item['nome_do_bloco'] as String,
    ),
    ColumnData(
      label: 'Descrição',
      getValue: (item) => item['descricao'] as String,
    ),
    ColumnData(
      label: 'Campus',
      getValue: (item) => item['campus_display'] as String, // Using a display string for campus
    ),
  ];

  @override
  void initState() {
    super.initState();
    _blocoService = BlocoService();
    _fetchBlocos();
  }

  Future<void> _fetchBlocos() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
    });
    try {
      _actualBlocos = await _blocoService.getBlocos();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Erro ao buscar blocos: ${e.toString()}')),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  // Helper to convert Bloco to Map for CustomCrudScreen items and handlers
  Map<String, dynamic> _blocoToMap(Bloco bloco) {
    return {
      'id_internal': bloco.id,
      'nome_do_bloco': bloco.name,
      'descricao': bloco.description ?? '',
      'campus_raw': bloco.campus.name, // Mantém o nome do enum para lógica interna
      'campus_display': _getFormattedCampusName(bloco.campus.name), // Usa a função para exibição
      '_original_bloco_object': bloco,
    };
  }

  String _formatCampusName(Campus campus) { // Esta função pode ser removida ou substituída por _getFormattedCampusName se a entrada for sempre string
    return _getFormattedCampusName(campus.name);
  }


  Future<void> _handleEdit(Map<String, dynamic> itemMapFromCrud) async {
    final Bloco originalBloco = itemMapFromCrud['_original_bloco_object'] as Bloco;

    final nomeController = TextEditingController(text: originalBloco.name);
    final descricaoController = TextEditingController(text: originalBloco.description);
    // String para armazenar o valor selecionado do dropdown (nome do enum)
    String selectedCampusName = originalBloco.campus.name;

    // Gerar itens para o dropdown
    final List<DropdownMenuItem<String>> campusDropdownItems = Campus.values.map((campus) {
      return DropdownMenuItem<String>(
        value: campus.name, // Valor é o nome do enum (ex: "maringa")
        child: Text(_getFormattedCampusName(campus.name)), // Texto exibido é formatado
      );
    }).toList();

    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) => CustomFormDialog(
        title: 'Editar Bloco',
        fields: [
          CustomFormField(
            label: 'Nome do Bloco',
            controller: nomeController,
            icon: Icons.apartment,
          ),
          CustomFormField(
            label: 'Descrição',
            controller: descricaoController,
            icon: Icons.description,
          ),
          CustomFormField(
            label: 'Campus',
            isDropdown: true,
            items: campusDropdownItems,
            value: selectedCampusName, // Valor inicial do dropdown (nome do enum)
            onChanged: (newValue) {
              if (newValue != null) {
                // Atualiza a variável local quando um novo campus é selecionado
                // Não é necessário setState aqui pois o CustomDropdown gerencia seu próprio estado visual.
                // Esta variável será usada no onSave.
                selectedCampusName = newValue;
              }
            },
            icon: Icons.location_on,
          ),
        ],
        onSave: (formDataFromDialog) { // formDataFromDialog é o mapa interno do CustomFormDialog, podemos ignorá-lo se controlamos os valores externamente
          Navigator.pop(context, {
            'nome_do_bloco': nomeController.text,
            'descricao': descricaoController.text,
            'campus': selectedCampusName, // Usa a variável atualizada pelo onChanged do dropdown
          });
        },
        onCancel: () => Navigator.pop(context),
      ),
    );

    if (result != null) {
      try {
        Campus campusValue;
        // result['campus'] já virá como o nome do enum (ex: "maringa")
        String campusInput = result['campus'].toString().toLowerCase();
        try {
            campusValue = Campus.values.byName(campusInput);
        } catch (_) {
            if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Valor de campus inválido: ${result['campus']}')),
                );
            }
            return;
        }
        final BlocoDTO updatedBloco = BlocoDTO(
          name: result['nome_do_bloco'] as String,
          description: result['descricao'] as String?,
          campus: campusValue,
          updatedAt: DateTime.now(),
        );
        await _blocoService.updateBloco(updatedBloco, originalBloco.id as int);
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('"${updatedBloco.name}" atualizado com sucesso.')),
          );
        }
        _fetchBlocos(); // Refresh list
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Erro ao atualizar bloco: ${e.toString()}')),
          );
        }
      }
    }

    // Limpar os controllers
    nomeController.dispose();
    descricaoController.dispose();
    // campusController não existe mais
  }

  void _handleDelete(Map<String, dynamic> itemMapFromCrud) async {
    final Bloco blocoToDelete = itemMapFromCrud['_original_bloco_object'] as Bloco;
    
    // Optional: Show confirmation dialog
    final confirmed = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
            title: const Text('Confirmar Exclusão'),
            content: Text('Tem certeza que deseja excluir o bloco "${blocoToDelete.name}"?'),
            actions: [
                TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Cancelar')),
                TextButton(onPressed: () => Navigator.pop(context, true), child: const Text('Excluir', style: TextStyle(color: Colors.red))),
            ],
        ),
    );

    if (confirmed == true) {
        try {
            await _blocoService.deleteBloco(blocoToDelete.id as int);
            _fetchBlocos(); // Refresh list
            if(mounted){
                 ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('"${blocoToDelete.name}" excluído com sucesso.')),
                );
            }
        } catch (e) {
            if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Erro ao excluir bloco: ${e.toString()}')),
            );
            }
        }
    }
  }

  Future<void> _handleAdd() async {
    final nomeController = TextEditingController();
    final descricaoController = TextEditingController();
    // String para armazenar o valor selecionado do dropdown, padrão para 'maringa'
    String selectedCampusName = Campus.maringa.name; 

    // Gerar itens para o dropdown
    final List<DropdownMenuItem<String>> campusDropdownItems = Campus.values.map((campus) {
      return DropdownMenuItem<String>(
        value: campus.name,
        child: Text(_getFormattedCampusName(campus.name)),
      );
    }).toList();

    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) => CustomFormDialog(
        title: 'Novo Bloco',
        fields: [
          CustomFormField(
            label: 'Nome do Bloco',
            controller: nomeController,
            icon: Icons.apartment,
          ),
          CustomFormField(
            label: 'Descrição',
            controller: descricaoController,
            icon: Icons.description,
          ),
          CustomFormField(
            label: 'Campus',
            isDropdown: true,
            items: campusDropdownItems,
            value: selectedCampusName, // Valor inicial do dropdown
            onChanged: (newValue) {
              if (newValue != null) {
                selectedCampusName = newValue;
              }
            },
            icon: Icons.location_on,
          ),
        ],
        onSave: (formDataFromDialog) {
           Navigator.pop(context, {
            'nome_do_bloco': nomeController.text,
            'descricao': descricaoController.text,
            'campus': selectedCampusName, // Usa a variável atualizada
          });
        },
        onCancel: () => Navigator.pop(context),
      ),
    );

    if (result != null) {
      try {
        Campus campusValue;
        // result['campus'] já virá como o nome do enum
        String campusInput = result['campus'].toString().toLowerCase();
        // A lógica de fallback para maringa se input for vazio já não é estritamente necessária
        // se o dropdown sempre tiver um valor, mas pode ser mantida por segurança se o dropdown
        // pudesse de alguma forma retornar nulo ou vazio e isso não fosse desejado.
        // if (campusInput.isEmpty) campusInput = Campus.maringa.name; // O dropdown deve garantir uma seleção

        try {
            campusValue = Campus.values.byName(campusInput);
        } catch (_) {
            // Se o valor do dropdown for inválido (não deveria acontecer se os itens são do enum)
            // ou se por algum motivo campusInput for algo inesperado.
            if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Valor de campus inválido: "$campusInput". Usando "${_getFormattedCampusName(Campus.maringa.name)}".')),
                );
            }
            campusValue = Campus.maringa; // Fallback
        }
        final BlocoDTO novoBloco = BlocoDTO(
          name: result['nome_do_bloco'] as String,
          description: result['descricao'] as String?,
          campus: campusValue,
          updatedAt: DateTime.now(),
        );
        
        await _blocoService.createBloco(novoBloco);
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('"${novoBloco.name}" adicionado com sucesso.')),
          );
        }
        _fetchBlocos(); // Refresh list to get the new item with its actual ID
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Erro ao adicionar bloco: ${e.toString()}')),
          );
        }
      }
    }
    // Limpar os controllers
    nomeController.dispose();
    descricaoController.dispose();
    // campusController não existe mais
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold( // Assuming CustomCrudScreen might not be a full Scaffold
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : CustomCrudScreen(
            fields: [],
              title: 'Blocos', // This title might be redundant if AppBar is used
              columns: _columns,
              items: _actualBlocos.map(_blocoToMap).toList(),
              // fields: const [], // Not used as per your original code
              onEdit: _handleEdit,
              onDelete: _handleDelete,
              onAdd: _handleAdd,
            ),
    );
  }
}
