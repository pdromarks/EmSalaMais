import 'package:em_sala_mais/backend/dto/bloco_dto.dart';
import 'package:em_sala_mais/backend/services/bloco.service.dart';
import 'package:flutter/material.dart';
import '../../components/screens/custom_crud_screen.dart'; // Assuming this is correctly defined
import '../../components/screens/custom_form_dialog.dart'; // Assuming this is correctly defined
import 'package:em_sala_mais/backend/model/bloco.dart'; // Your Bloco model
import 'package:em_sala_mais/backend/model/enums.dart'; // Your Campus enum


class BlocoCrudScreen extends StatefulWidget {
  const BlocoCrudScreen({super.key});

  @override
  State<BlocoCrudScreen> createState() => _BlocoCrudScreenState();
}

class _BlocoCrudScreenState extends State<BlocoCrudScreen> {
  late BlocoService _blocoService;
  List<Bloco> _actualBlocos = [];
  bool _isLoading = true;

  // Definição das colunas da tabela
  // These columns operate on the Map<String, dynamic> generated by _blocoToMap
  final List<ColumnData> _columns = [
    ColumnData(
      label: 'Nome',
      getValue: (item) => item['nome_do_bloco'] as String,
    ),
    ColumnData(
      label: 'Descrição',
      getValue: (item) => item['descricao'] as String,
    ),
    ColumnData(
      label: 'Campus',
      getValue: (item) => item['campus_display'] as String, // Using a display string for campus
    ),
  ];

  @override
  void initState() {
    super.initState();
    _blocoService = BlocoService();
    _fetchBlocos();
  }

  Future<void> _fetchBlocos() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
    });
    try {
      _actualBlocos = await _blocoService.getBlocos();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Erro ao buscar blocos: ${e.toString()}')),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  // Helper to convert Bloco to Map for CustomCrudScreen items and handlers
  Map<String, dynamic> _blocoToMap(Bloco bloco) {
    return {
      'id_internal': bloco.id, // Keep original int id for backend operations
      'nome_do_bloco': bloco.name,
      'descricao': bloco.description ?? '', // Ensure non-null for display
      'campus_raw': bloco.campus.name, // Raw enum name string
      'campus_display': _formatCampusName(bloco.campus), // User-friendly campus name
      '_original_bloco_object': bloco, // To easily retrieve the Bloco object
    };
  }

  String _formatCampusName(Campus campus) {
    // Example: Convert 'maringa' to 'Maringá'
    if (campus.name.toLowerCase() == 'maringa') return 'Maringá';
    return campus.name[0].toUpperCase() + campus.name.substring(1);
  }


  Future<void> _handleEdit(Map<String, dynamic> itemMapFromCrud) async {
    final Bloco originalBloco = itemMapFromCrud['_original_bloco_object'] as Bloco;

    final nomeController = TextEditingController(text: originalBloco.name);
    final descricaoController = TextEditingController(text: originalBloco.description);
    // Assuming CustomFormDialog will use campus_raw for the controller's initial value if it's a dropdown/selector
    // or if it's a text field, it should be the string representation of the enum.
    final campusController = TextEditingController(text: originalBloco.campus.name);

    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) => CustomFormDialog(
        title: 'Editar Bloco',
        // initialData could be used by CustomFormDialog if controllers are not directly manipulated
        // For this example, controllers are explicitly set.
        // initialData: itemMapFromCrud, 
        fields: [
          CustomFormField(
            label: 'Nome do Bloco',
            controller: nomeController,
            icon: Icons.apartment,
          ),
          CustomFormField(
            label: 'Descrição',
            controller: descricaoController,
            icon: Icons.description,
          ),
          CustomFormField(
            label: 'Campus', // This label must match the key in formData returned by onSave
            controller: campusController,
            icon: Icons.location_on,
            // If 'Campus' is a dropdown, you'd configure it here.
            // For now, assuming it's a text field where user types enum string e.g. "maringa"
          ),
        ],
        onSave: (formData) { // formData keys should match CustomFormField labels or defined keys
          // Ensure formData contains 'Nome do Bloco', 'Descrição', 'Campus'
          // Let's assume CustomFormDialog returns keys based on labels, transformed to be more code-friendly
          // For simplicity, let's assume CustomFormDialog returns:
          // {'nome_do_bloco': value, 'descricao': value, 'campus': value}
          // This depends on your CustomFormDialog implementation.
          // For this example, we'll assume the controllers' text is directly used.
          Navigator.pop(context, {
            'nome_do_bloco': nomeController.text,
            'descricao': descricaoController.text,
            'campus': campusController.text, // This will be the string e.g. "maringa"
          });
        },
        onCancel: () => Navigator.pop(context),
      ),
    );

    if (result != null) {
      try {
        Campus campusValue;
        try {
            campusValue = Campus.values.byName(result['campus'].toString().toLowerCase());
        } catch (_) {
            if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Valor de campus inválido: ${result['campus']}')),
                );
            }
            return;
        }
        final BlocoDTO updatedBloco = BlocoDTO(
          name: result['nome_do_bloco'] as String,
          description: result['descricao'] as String?,
          campus: campusValue,
          updatedAt: DateTime.now(),
        );
        await _blocoService.updateBloco(updatedBloco, originalBloco.id as int);
        _fetchBlocos(); // Refresh list
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Erro ao atualizar bloco: ${e.toString()}')),
          );
        }
      }
    }

    // Limpar os controllers
    nomeController.dispose();
    descricaoController.dispose();
    campusController.dispose();
  }

  void _handleDelete(Map<String, dynamic> itemMapFromCrud) async {
    final Bloco blocoToDelete = itemMapFromCrud['_original_bloco_object'] as Bloco;
    
    // Optional: Show confirmation dialog
    final confirmed = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
            title: const Text('Confirmar Exclusão'),
            content: Text('Tem certeza que deseja excluir o bloco "${blocoToDelete.name}"?'),
            actions: [
                TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Cancelar')),
                TextButton(onPressed: () => Navigator.pop(context, true), child: const Text('Excluir')),
            ],
        ),
    );

    if (confirmed == true) {
        try {
            await _blocoService.deleteBloco(blocoToDelete.id as int);
            _fetchBlocos(); // Refresh list
            if(mounted){
                 ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Bloco "${blocoToDelete.name}" excluído com sucesso.')),
                );
            }
        } catch (e) {
            if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Erro ao excluir bloco: ${e.toString()}')),
            );
            }
        }
    }
  }

  Future<void> _handleAdd() async {
    final nomeController = TextEditingController();
    final descricaoController = TextEditingController();
    final campusController = TextEditingController(); // Default to empty or a common campus

    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) => CustomFormDialog(
        title: 'Novo Bloco',
        fields: [
          CustomFormField(
            label: 'Nome do Bloco',
            controller: nomeController,
            icon: Icons.apartment,
          ),
          CustomFormField(
            label: 'Descrição',
            controller: descricaoController,
            icon: Icons.description,
          ),
          CustomFormField(
            label: 'Campus',
            controller: campusController,
            icon: Icons.location_on,
            // Consider making this a dropdown populated with Campus.values
            // For now, user types enum string e.g. "maringa"
          ),
        ],
        onSave: (formData) { // formData keys should match CustomFormField labels or defined keys
           Navigator.pop(context, {
            'nome_do_bloco': nomeController.text,
            'descricao': descricaoController.text,
            'campus': campusController.text, // This will be the string e.g. "maringa"
          });
        },
        onCancel: () => Navigator.pop(context),
      ),
    );

    if (result != null) {
      try {
        Campus campusValue;
        String campusInput = result['campus'].toString().toLowerCase();
        if (campusInput.isEmpty) campusInput = Campus.maringa.name; // Default if empty

        try {
            campusValue = Campus.values.byName(campusInput);
        } catch (_) {
            if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Valor de campus inválido: "${result['campus']}". Usando "${Campus.maringa.name}".')),
                );
            }
            campusValue = Campus.maringa; // Fallback to a default campus
        }
        final BlocoDTO novoBloco = BlocoDTO(
          name: result['nome_do_bloco'] as String,
          description: result['descricao'] as String?,
          campus: campusValue,
          updatedAt: DateTime.now(),
        );
        
        await _blocoService.createBloco(novoBloco);
        _fetchBlocos(); // Refresh list to get the new item with its actual ID
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Erro ao adicionar bloco: ${e.toString()}')),
          );
        }
      }
    }
    // Limpar os controllers
    nomeController.dispose();
    descricaoController.dispose();
    campusController.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold( // Assuming CustomCrudScreen might not be a full Scaffold
      appBar: AppBar(
        title: const Text('Gerenciar Blocos'),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : CustomCrudScreen(
            fields: [],
              title: 'Blocos', // This title might be redundant if AppBar is used
              columns: _columns,
              items: _actualBlocos.map(_blocoToMap).toList(),
              // fields: const [], // Not used as per your original code
              onEdit: _handleEdit,
              onDelete: _handleDelete,
              onAdd: _handleAdd,
            ),
    );
  }
}

// Ensure your CustomFormField and ColumnData classes are defined as they were.
// For example:
// class ColumnData {
//   final String label;
//   final String Function(Map<String, dynamic> item) getValue;
//   ColumnData({required this.label, required this.getValue});
// }
// class CustomFormField {
//   final String label;
//   final TextEditingController controller;
//   final IconData? icon;
//   CustomFormField({required this.label, required this.controller, this.icon});
// }